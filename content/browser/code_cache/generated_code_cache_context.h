// Copyright 2018 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_BROWSER_CODE_CACHE_GENERATED_CODE_CACHE_CONTEXT_H_
#define CONTENT_BROWSER_CODE_CACHE_GENERATED_CODE_CACHE_CONTEXT_H_

#include "base/files/file_path.h"
#include "base/memory/ref_counted.h"
#include "base/task/sequenced_task_runner.h"
#include "base/thread_annotations.h"
#include "components/persistent_cache/persistent_cache_collection.h"
#include "content/common/content_export.h"
#include "content/public/browser/browser_thread.h"

namespace content {

class GeneratedCodeCache;

// One instance exists per disk-backed (non in-memory) storage contexts. This
// owns the instance of GeneratedCodeCache that is used to store the data
// generated by the renderer (for ex: code caches for script resources). This
// initializes and closes the code cache on the code cache thread. The
// instance of this class (|this|) itself is constructed on the UI thread.
class CONTENT_EXPORT GeneratedCodeCacheContext
    : public base::RefCountedThreadSafe<GeneratedCodeCacheContext> {
 public:
  REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE();

  // Runs a task on the code cache thread, or immediately if already on the code
  // cache thread.
  static void RunOrPostTask(scoped_refptr<GeneratedCodeCacheContext> context,
                            const base::Location& location,
                            base::OnceClosure task);

  // Gets the task runner for the code cache thread.
  static scoped_refptr<base::SequencedTaskRunner> GetTaskRunner(
      scoped_refptr<GeneratedCodeCacheContext> context);

  GeneratedCodeCacheContext();

  GeneratedCodeCacheContext(const GeneratedCodeCacheContext&) = delete;
  GeneratedCodeCacheContext& operator=(const GeneratedCodeCacheContext&) =
      delete;

  // Initialize is called on the UI thread when the StoragePartition is
  // being setup.
  void Initialize(const base::FilePath& path, int max_bytes);

  void Shutdown();

  // Call on the code cache thread to get the code cache instances.
  GeneratedCodeCache* generated_js_code_cache() const;
  GeneratedCodeCache* generated_wasm_code_cache() const;
  GeneratedCodeCache* generated_webui_js_code_cache() const;

  // Use to get rid of code cached in the PersistentCache collection both in
  // memory and persisted.
  void ClearAndDeletePersistentCacheCollection();

  // Using a persistent cache collection with `context_key` as the cache_id
  // makes sure that there are seperate files for separate process locks. This
  // will eventually allow the sharing of the files with the renderers.
  void InsertIntoPersistentCacheCollection(
      const std::string& context_key,
      std::string_view url,
      base::span<const uint8_t> content,
      persistent_cache::EntryMetadata metadata);

  // TODO(crbug.com/377475540): Use types that are not interchangeable for
  // `context_key` and `url` so that they cannot be mixed up by mistake.
  std::unique_ptr<persistent_cache::Entry> FindInPersistentCacheCollection(
      const std::string& context_key,
      std::string_view url);

 private:
  friend class base::RefCountedThreadSafe<GeneratedCodeCacheContext>;
  ~GeneratedCodeCacheContext();

  void InitializeOnThread(const base::FilePath& path, int max_bytes);
  void ShutdownOnThread();

  // Created, used and deleted on the code cache thread.
  std::unique_ptr<GeneratedCodeCache, base::OnTaskRunnerDeleter>
      generated_js_code_cache_ GUARDED_BY_CONTEXT(sequence_checker_) = {
          nullptr, base::OnTaskRunnerDeleter(nullptr)};
  std::unique_ptr<GeneratedCodeCache, base::OnTaskRunnerDeleter>
      generated_wasm_code_cache_ GUARDED_BY_CONTEXT(sequence_checker_) = {
          nullptr, base::OnTaskRunnerDeleter(nullptr)};
  std::unique_ptr<GeneratedCodeCache, base::OnTaskRunnerDeleter>
      generated_webui_js_code_cache_ GUARDED_BY_CONTEXT(sequence_checker_) = {
          nullptr, base::OnTaskRunnerDeleter(nullptr)};
  scoped_refptr<base::SequencedTaskRunner> task_runner_;

  // When used instead of `generated_js_code_cache_` this stores the code
  // following the same isolation principles but using two keys instead of one.
  // The first key is used to get a `PersistentCache` associated with an
  // isolation context from the collection. This insures that each isolation
  // context uses a seperate database file. The second key is the resource
  // url used on that cache.
  std::unique_ptr<persistent_cache::PersistentCacheCollection,
                  base::OnTaskRunnerDeleter>
      persistent_cache_collection_{nullptr, base::OnTaskRunnerDeleter(nullptr)};

  SEQUENCE_CHECKER(sequence_checker_);
};

}  // namespace content

#endif  // CONTENT_BROWSER_CODE_CACHE_GENERATED_CODE_CACHE_CONTEXT_H_
